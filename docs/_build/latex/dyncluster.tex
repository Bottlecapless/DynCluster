%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,openany,oneside,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[Scale=0.9,
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}


\usepackage{ctex}


\title{DynCluster}
\date{Jun 19, 2025}
\release{0.0.1}
\author{Yingxiao Wang}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
Add your content using \sphinxcode{\sphinxupquote{reStructuredText}} syntax. See the
\sphinxhref{https://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html}{reStructuredText}
documentation for details.

\sphinxstepscope


\chapter{source code}
\label{\detokenize{code:source-code}}\label{\detokenize{code::doc}}

\section{\sphinxstyleliteralintitle{\sphinxupquote{main.py}}}
\label{\detokenize{code:main-py}}\sphinxSetupCaptionForVerbatim{main.py}
\def\sphinxLiteralBlockLabel{\label{\detokenize{code:id1}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{This project is a course project for Prof. Qinwu Xu\PYGZsq{}s \PYGZdq{}Mathematical Theory of Machine Learning\PYGZdq{} (Spring 2025), School of Mathematics, Nanjing University. It mainly focuses on the problem of dynamic clustering.}

\PYG{l+s+sd}{The core process is as follows:}
\PYG{l+s+sd}{→ New data stream arrives  }
\PYG{l+s+sd}{→ Perform clustering on the new data  }
\PYG{l+s+sd}{→ Update cluster centers and adjust previous clustering results  }
\PYG{l+s+sd}{→ If any cluster becomes too large, it is split  }
\PYG{l+s+sd}{→ Adjust the clustering result accordingly  }
\PYG{l+s+sd}{→ Wait for the next batch of data}

\PYG{l+s+sd}{Author: Yingxiao Wang  }
\PYG{l+s+sd}{Email: wangbottlecap@gmail.com}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{import} \PYG{n+nn}{logger}
\PYG{k+kn}{from} \PYG{n+nn}{constants}\PYG{n+nn}{.}\PYG{n+nn}{constants} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{backgrounds} \PYG{k+kn}{import} \PYG{n}{DataReader}
\PYG{k+kn}{from} \PYG{n+nn}{optimizer} \PYG{k+kn}{import} \PYG{n}{DynamicKmeansController}\PYG{p}{,} \PYG{n}{StaticKmeansController}
\PYG{k+kn}{from} \PYG{n+nn}{processer} \PYG{k+kn}{import} \PYG{n}{ComparisonProcessor}
\PYG{k+kn}{from} \PYG{n+nn}{plotter} \PYG{k+kn}{import} \PYG{n}{ComparisonPlotter}

\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    }
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{LOGGER} \PYG{o}{=} \PYG{n}{logger}\PYG{o}{.}\PYG{n}{setup\PYGZus{}logging}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{LOGGER}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This project is a course project for Prof. Qinwu Xu}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s Mathematical Theory of Machine Learning (Spring 2025), School of Mathematics, Nanjing University. It mainly focuses on the problem of dynamic clustering.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    
    \PYG{n}{rd} \PYG{o}{=} \PYG{n}{DataReader}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{rd}\PYG{o}{.}\PYG{n}{read\PYGZus{}fvecs}\PYG{p}{(}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{rd}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}

    \PYG{n}{dyn} \PYG{o}{=} \PYG{n}{DynamicKmeansController}\PYG{p}{(}\PYG{n}{data}\PYG{o}{=}\PYG{n}{rd}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}
    \PYG{n}{dyn}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{p}{)}
    
    \PYG{n}{sta} \PYG{o}{=} \PYG{n}{StaticKmeansController}\PYG{p}{(}\PYG{n}{data}\PYG{o}{=}\PYG{n}{rd}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{n}{dyn}\PYG{o}{.}\PYG{n}{getCentroidsNum}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{sta}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{p}{)}

    \PYG{n}{processer} \PYG{o}{=} \PYG{n}{ComparisonProcessor}\PYG{p}{(}\PYG{n}{dyn}\PYG{p}{,} \PYG{n}{sta}\PYG{p}{)}
    \PYG{n}{plotter} \PYG{o}{=} \PYG{n}{ComparisonPlotter}\PYG{p}{(}\PYG{n}{processer}\PYG{p}{)}
    \PYG{n}{plotter}\PYG{o}{.}\PYG{n}{print\PYGZus{}center\PYGZus{}distance}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plotter}\PYG{o}{.}\PYG{n}{plotAll}\PYG{p}{(}\PYG{p}{)}
    
    \PYG{k}{return}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\section{\sphinxstyleliteralintitle{\sphinxupquote{optimizer.py}}}
\label{\detokenize{code:optimizer-py}}\sphinxSetupCaptionForVerbatim{optimizer.py}
\def\sphinxLiteralBlockLabel{\label{\detokenize{code:id2}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{time}
\PYG{k+kn}{from} \PYG{n+nn}{sklearn}\PYG{n+nn}{.}\PYG{n+nn}{cluster} \PYG{k+kn}{import} \PYG{n}{KMeans}

\PYG{k+kn}{import} \PYG{n+nn}{logging}
\PYG{n}{LOGGER} \PYG{o}{=} \PYG{n}{logging}\PYG{o}{.}\PYG{n}{getLogger}\PYG{p}{(}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{)}

\PYG{k}{class} \PYG{n+nc}{DynamicKmeansController}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Dynamic KMeans clustering controller for streaming data.}

\PYG{l+s+sd}{    Core process:}
\PYG{l+s+sd}{    → New data batch arrives}
\PYG{l+s+sd}{    → Assign new points to existing clusters (or initialize)}
\PYG{l+s+sd}{    → Update cluster centers}
\PYG{l+s+sd}{    → Split clusters exceeding max\PYGZus{}size into two}
\PYG{l+s+sd}{    → Compute and print current loss}
\PYG{l+s+sd}{    → Repeat for next batch}

\PYG{l+s+sd}{    Attributes:}
\PYG{l+s+sd}{        data (np.ndarray): full dataset for indexing.}
\PYG{l+s+sd}{        batch\PYGZus{}size (int): number of points per incoming batch.}
\PYG{l+s+sd}{        min\PYGZus{}size (int): minimum cluster size before merge (future extension).}
\PYG{l+s+sd}{        max\PYGZus{}size (int): maximum cluster size before split.}
\PYG{l+s+sd}{        centroids (list[np.ndarray]): current cluster centers.}
\PYG{l+s+sd}{        cluster\PYGZus{}data\PYGZus{}indices (dict[int, list[int]]): mapping cluster IDs to data indices.}
\PYG{l+s+sd}{        assignments (dict[int, int]): mapping data index to its cluster ID.}
\PYG{l+s+sd}{        loss\PYGZus{}history (list[float]): recorded loss after each batch.}
\PYG{l+s+sd}{        time\PYGZus{}history (list[float]): cumulative processing time after each batch.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{data}\PYG{p}{:}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{,} \PYG{n}{batch\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{min\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{60}\PYG{p}{,} \PYG{n}{max\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{150}\PYG{p}{,} \PYG{n}{ratio} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{,}\PYG{n}{threshold} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{data}                                  \PYG{c+c1}{\PYGZsh{} 保存整个数据集}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n}{batch\PYGZus{}size}                      \PYG{c+c1}{\PYGZsh{} 每次处理的批大小}
        \PYG{c+c1}{\PYGZsh{} self.threshold = threshold}
        \PYG{c+c1}{\PYGZsh{} self.ratio = ratio}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{min\PYGZus{}size} \PYG{o}{=} \PYG{n}{min\PYGZus{}size}                          \PYG{c+c1}{\PYGZsh{} 最小簇大小（留作合并条件） }
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{max\PYGZus{}size} \PYG{o}{=} \PYG{n}{max\PYGZus{}size}                          \PYG{c+c1}{\PYGZsh{} 最大簇大小（超过需分裂）}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{centroids} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}                               \PYG{c+c1}{\PYGZsh{} 存储当前簇中心列表}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cluster\PYGZus{}data\PYGZus{}indices} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}                    \PYG{c+c1}{\PYGZsh{} 存储簇ID到样本索引的映射}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{assignments} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}                             \PYG{c+c1}{\PYGZsh{} 存储样本索引到簇ID的映射}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{loss\PYGZus{}history} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}                            \PYG{c+c1}{\PYGZsh{} 记录每批的损失值（inertia）}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{time\PYGZus{}history} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}                            \PYG{c+c1}{\PYGZsh{} 记录累计时间}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}current\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mf}{0.0}                          \PYG{c+c1}{\PYGZsh{} 内部跟踪累计运行时间}

    \PYG{k}{def} \PYG{n+nf}{getCentroidsNum}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:} \PYG{k}{return} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{centroids}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Run dynamic clustering over the entire dataset in streaming batches.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n}{n\PYGZus{}points} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}                     \PYG{c+c1}{\PYGZsh{} 数据总样本数}
        \PYG{c+c1}{\PYGZsh{} 按批次遍历数据}
        \PYG{k}{for} \PYG{n}{batch\PYGZus{}start} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{n\PYGZus{}points}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{batch\PYGZus{}size}\PYG{p}{)}\PYG{p}{:}
            \PYG{c+c1}{\PYGZsh{} 计算本批样本全局索引范围}
            \PYG{n}{batch\PYGZus{}indices} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{batch\PYGZus{}start}\PYG{p}{,} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{batch\PYGZus{}start} \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{batch\PYGZus{}size}\PYG{p}{,} \PYG{n}{n\PYGZus{}points}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{batch} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{batch\PYGZus{}indices}\PYG{p}{]}              \PYG{c+c1}{\PYGZsh{} 提取本批数据}
            \PYG{n}{t0} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}                              \PYG{c+c1}{\PYGZsh{} 计时开始}

            \PYG{c+c1}{\PYGZsh{} 增量聚类、更新中心、拆分过大簇}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}add\PYGZus{}batch}\PYG{p}{(}\PYG{n}{batch}\PYG{p}{,} \PYG{n}{batch\PYGZus{}indices}\PYG{p}{)}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}update\PYGZus{}clusters}\PYG{p}{(}\PYG{p}{)}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}split\PYGZus{}large\PYGZus{}clusters}\PYG{p}{(}\PYG{p}{)}

            \PYG{n}{batch\PYGZus{}loss} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}compute\PYGZus{}loss}\PYG{p}{(}\PYG{p}{)}             \PYG{c+c1}{\PYGZsh{} 计算本批后总损失}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}current\PYGZus{}time} \PYG{o}{+}\PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{t0}        \PYG{c+c1}{\PYGZsh{} 更新累计时间}

            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{loss\PYGZus{}history}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{batch\PYGZus{}loss}\PYG{p}{)}          \PYG{c+c1}{\PYGZsh{} 记录损失}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{time\PYGZus{}history}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}current\PYGZus{}time}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} 记录时间}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Batch }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{batch\PYGZus{}start}\PYG{o}{/}\PYG{o}{/}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{batch\PYGZus{}size}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{: Loss = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{batch\PYGZus{}loss}\PYG{l+s+si}{:}\PYG{l+s+s2}{.4f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, Time = }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}current\PYGZus{}time}\PYG{l+s+si}{:}\PYG{l+s+s2}{.4f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{s}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}add\PYGZus{}batch}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{batch}\PYG{p}{,} \PYG{n}{indices}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Assign a new batch of points to clusters or initialize clustering.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{centroids}\PYG{p}{:}                           \PYG{c+c1}{\PYGZsh{} 如果还没有簇中心（首次调用）}
            \PYG{c+c1}{\PYGZsh{} 计算初始簇数：确保至少1个簇}
            \PYG{n}{k\PYGZus{}init} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{batch}\PYG{p}{)} \PYG{o}{/}\PYG{o}{/} \PYG{p}{(}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{min\PYGZus{}size} \PYG{o}{+} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{max\PYGZus{}size}\PYG{p}{)} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} k\PYGZus{}init = max(1, int(self.batch\PYGZus{}size * self.ratio))}
            \PYG{c+c1}{\PYGZsh{} 使用 KMeans 对首批数据做静态聚类初始化}
            \PYG{n}{km} \PYG{o}{=} \PYG{n}{KMeans}\PYG{p}{(}\PYG{n}{n\PYGZus{}clusters}\PYG{o}{=}\PYG{n}{k\PYGZus{}init}\PYG{p}{,} \PYG{n}{init}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k\PYGZhy{}means++}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{random\PYGZus{}state}\PYG{o}{=}\PYG{l+m+mi}{42}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{batch}\PYG{p}{)}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{centroids} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{km}\PYG{o}{.}\PYG{n}{cluster\PYGZus{}centers\PYGZus{}}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} 保存初始簇中心}
            \PYG{c+c1}{\PYGZsh{} 记录每个样本的簇标签}
            \PYG{k}{for} \PYG{n}{idx}\PYG{p}{,} \PYG{n}{lbl} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{indices}\PYG{p}{,} \PYG{n}{km}\PYG{o}{.}\PYG{n}{labels\PYGZus{}}\PYG{p}{)}\PYG{p}{:}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{assignments}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{]} \PYG{o}{=} \PYG{n}{lbl}
            \PYG{c+c1}{\PYGZsh{} 构建簇到样本索引的映射}
            \PYG{k}{for} \PYG{n}{cid} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{k\PYGZus{}init}\PYG{p}{)}\PYG{p}{:}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cluster\PYGZus{}data\PYGZus{}indices}\PYG{p}{[}\PYG{n}{cid}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{idx} \PYG{k}{for} \PYG{n}{idx} \PYG{o+ow}{in} \PYG{n}{indices} \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{assignments}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{]} \PYG{o}{==} \PYG{n}{cid}\PYG{p}{]}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{c+c1}{\PYGZsh{} 对后续批次，遍历每个新点}
            \PYG{k}{for} \PYG{n}{idx}\PYG{p}{,} \PYG{n}{point} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{indices}\PYG{p}{,} \PYG{n}{batch}\PYG{p}{)}\PYG{p}{:}
                \PYG{c+c1}{\PYGZsh{} 计算该点到所有簇中心的欧氏距离}
                \PYG{n}{distances} \PYG{o}{=} \PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{point} \PYG{o}{\PYGZhy{}} \PYG{n}{c}\PYG{p}{)} \PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{centroids}\PYG{p}{]}
                \PYG{n}{lbl} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{argmin}\PYG{p}{(}\PYG{n}{distances}\PYG{p}{)}\PYG{p}{)}            \PYG{c+c1}{\PYGZsh{} 选择最近的簇}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{assignments}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{]} \PYG{o}{=} \PYG{n}{lbl}                 \PYG{c+c1}{\PYGZsh{} 更新样本\PYGZhy{}簇映射}
                \PYG{c+c1}{\PYGZsh{} 将样本索引追加到对应簇的列表中}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cluster\PYGZus{}data\PYGZus{}indices}\PYG{o}{.}\PYG{n}{setdefault}\PYG{p}{(}\PYG{n}{lbl}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{idx}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}update\PYGZus{}clusters}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Recompute centroids based on current cluster memberships.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{c+c1}{\PYGZsh{} 遍历所有簇}
        \PYG{k}{for} \PYG{n}{cid}\PYG{p}{,} \PYG{n}{members} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cluster\PYGZus{}data\PYGZus{}indices}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
            \PYG{c+c1}{\PYGZsh{} 提取该簇对应的所有样本点}
            \PYG{n}{pts} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{members}\PYG{p}{]}\PYG{p}{)}
            \PYG{k}{if} \PYG{n}{pts}\PYG{o}{.}\PYG{n}{size} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
                \PYG{c+c1}{\PYGZsh{} 重新计算簇中心为样本均值}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{centroids}\PYG{p}{[}\PYG{n}{cid}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pts}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}split\PYGZus{}large\PYGZus{}clusters}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Split any cluster larger than max\PYGZus{}size into two subclusters.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{c+c1}{\PYGZsh{} 下一个可用簇ID}
        \PYG{n}{next\PYGZus{}cid} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cluster\PYGZus{}data\PYGZus{}indices}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{default}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}
        \PYG{c+c1}{\PYGZsh{} 找出需要分裂的簇ID列表}
        \PYG{n}{oversized} \PYG{o}{=} \PYG{p}{[}\PYG{n}{cid} \PYG{k}{for} \PYG{n}{cid}\PYG{p}{,} \PYG{n}{members} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cluster\PYGZus{}data\PYGZus{}indices}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)} \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{members}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{max\PYGZus{}size}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{cid} \PYG{o+ow}{in} \PYG{n}{oversized}\PYG{p}{:}
            \PYG{n}{members} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cluster\PYGZus{}data\PYGZus{}indices}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{n}{cid}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} 暂时移除该簇}
            \PYG{n}{pts} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{members}\PYG{p}{]}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} 对过大簇内样本再次做2簇KMeans拆分}
            \PYG{n}{km2} \PYG{o}{=} \PYG{n}{KMeans}\PYG{p}{(}\PYG{n}{n\PYGZus{}clusters}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{init}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k\PYGZhy{}means++}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{random\PYGZus{}state}\PYG{o}{=}\PYG{l+m+mi}{42}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{pts}\PYG{p}{)}
            \PYG{n}{centers2} \PYG{o}{=} \PYG{n}{km2}\PYG{o}{.}\PYG{n}{cluster\PYGZus{}centers\PYGZus{}}
            \PYG{n}{labels2} \PYG{o}{=} \PYG{n}{km2}\PYG{o}{.}\PYG{n}{labels\PYGZus{}}

            \PYG{c+c1}{\PYGZsh{} 更新原簇中心及成员}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{centroids}\PYG{p}{[}\PYG{n}{cid}\PYG{p}{]} \PYG{o}{=} \PYG{n}{centers2}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cluster\PYGZus{}data\PYGZus{}indices}\PYG{p}{[}\PYG{n}{cid}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{members}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{labels2}\PYG{p}{)} \PYG{k}{if} \PYG{n}{l} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{]}

            \PYG{c+c1}{\PYGZsh{} 添加新簇中心及成员}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{centroids}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{centers2}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cluster\PYGZus{}data\PYGZus{}indices}\PYG{p}{[}\PYG{n}{next\PYGZus{}cid}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{members}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{labels2}\PYG{p}{)} \PYG{k}{if} \PYG{n}{l} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{]}

            \PYG{c+c1}{\PYGZsh{} 更新分裂后所有样本的簇归属}
            \PYG{k}{for} \PYG{n}{idx}\PYG{p}{,} \PYG{n}{lbl} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{members}\PYG{p}{,} \PYG{n}{labels2}\PYG{p}{)}\PYG{p}{:}
                \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{assignments}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{]} \PYG{o}{=} \PYG{n}{cid} \PYG{k}{if} \PYG{n}{lbl} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{k}{else} \PYG{n}{next\PYGZus{}cid}

            \PYG{n}{next\PYGZus{}cid} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}                            \PYG{c+c1}{\PYGZsh{} 更新下一个可用簇ID}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}compute\PYGZus{}loss}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Compute total inertia (sum of squared distances) as loss.\PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n}{total\PYGZus{}loss} \PYG{o}{=} \PYG{l+m+mf}{0.0}
        \PYG{c+c1}{\PYGZsh{} 遍历每个簇计算簇内平方和}
        \PYG{k}{for} \PYG{n}{cid}\PYG{p}{,} \PYG{n}{members} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cluster\PYGZus{}data\PYGZus{}indices}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{center} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{centroids}\PYG{p}{[}\PYG{n}{cid}\PYG{p}{]}                \PYG{c+c1}{\PYGZsh{} 当前簇中心}
            \PYG{n}{pts} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{members}\PYG{p}{]}\PYG{p}{)}
            \PYG{n}{total\PYGZus{}loss} \PYG{o}{+}\PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{(}\PYG{n}{pts} \PYG{o}{\PYGZhy{}} \PYG{n}{center}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} 累加平方误差}
        \PYG{k}{return} \PYG{n}{total\PYGZus{}loss}
    


\PYG{k}{class} \PYG{n+nc}{StaticKmeansController}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Static KMeans clustering controller using faiss for full\PYGZhy{}dataset clustering.}

\PYG{l+s+sd}{    Attributes:}
\PYG{l+s+sd}{        data (np.ndarray): Full dataset of shape (N, D), dtype float32.}
\PYG{l+s+sd}{        k (int): Number of clusters.}
\PYG{l+s+sd}{        niter (int): Number of iterations for faiss KMeans.}
\PYG{l+s+sd}{        seed (int): Random seed for reproducibility.}
\PYG{l+s+sd}{        centroids (np.ndarray): Final cluster centers of shape (k, D).}
\PYG{l+s+sd}{        assignments (dict[int, int]): Mapping from data index to assigned cluster ID.}
\PYG{l+s+sd}{        cluster\PYGZus{}data\PYGZus{}indices (dict[int, list[int]]): Mapping from cluster ID to list of data indices.}
\PYG{l+s+sd}{        loss (float): Final inertia (sum of squared distances to centroids).}
\PYG{l+s+sd}{        time\PYGZus{}taken (float): Time spent on clustering (seconds).}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{data}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{,} \PYG{n}{k}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{,} \PYG{n}{niter}\PYG{p}{:} \PYG{n+nb}{int} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{seed}\PYG{p}{:} \PYG{n+nb}{int} \PYG{o}{=} \PYG{l+m+mi}{42}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{float32}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{k} \PYG{o}{=} \PYG{n}{k}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{niter} \PYG{o}{=} \PYG{n}{niter}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{seed} \PYG{o}{=} \PYG{n}{seed}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{centroids} \PYG{o}{=} \PYG{k+kc}{None}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{assignments} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cluster\PYGZus{}data\PYGZus{}indices} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{loss} \PYG{o}{=} \PYG{k+kc}{None}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{time\PYGZus{}taken} \PYG{o}{=} \PYG{k+kc}{None}

    \PYG{k}{def} \PYG{n+nf}{run}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Run static KMeans clustering using faiss.Kmeans.}
\PYG{l+s+sd}{        Records centroids, assignments, cluster\PYGZus{}data\PYGZus{}indices, loss, and time\PYGZus{}taken.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{try}\PYG{p}{:}
            \PYG{k+kn}{import} \PYG{n+nn}{faiss}
        \PYG{k}{except} \PYG{n+ne}{ImportError}\PYG{p}{:}
            \PYG{k}{raise} \PYG{n+ne}{ImportError}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{faiss library not installed. Please install faiss to use StaticKmeansController.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Initialize faiss KMeans}
        \PYG{n}{d} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{n}{kmeans} \PYG{o}{=} \PYG{n}{faiss}\PYG{o}{.}\PYG{n}{Kmeans}\PYG{p}{(}\PYG{n}{d}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{k}\PYG{p}{,} \PYG{n}{niter}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{niter}\PYG{p}{,} \PYG{n}{verbose}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{seed}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Train and time}
        \PYG{n}{start\PYGZus{}time} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{kmeans}\PYG{o}{.}\PYG{n}{train}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{time\PYGZus{}taken} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{start\PYGZus{}time}

        \PYG{c+c1}{\PYGZsh{} Retrieve centroids}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{centroids} \PYG{o}{=} \PYG{n}{kmeans}\PYG{o}{.}\PYG{n}{centroids}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Assign each point to the nearest centroid}
        \PYG{n}{distances}\PYG{p}{,} \PYG{n}{labels} \PYG{o}{=} \PYG{n}{kmeans}\PYG{o}{.}\PYG{n}{index}\PYG{o}{.}\PYG{n}{search}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{labels} \PYG{o}{=} \PYG{n}{labels}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Build assignments and cluster\PYGZhy{}to\PYGZhy{}indices mapping}
        \PYG{k}{for} \PYG{n}{idx}\PYG{p}{,} \PYG{n}{lbl} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{labels}\PYG{p}{)}\PYG{p}{:}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{assignments}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{lbl}\PYG{p}{)}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cluster\PYGZus{}data\PYGZus{}indices}\PYG{o}{.}\PYG{n}{setdefault}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{lbl}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{idx}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Compute inertia (loss)}
        \PYG{n}{total\PYGZus{}loss} \PYG{o}{=} \PYG{l+m+mf}{0.0}
        \PYG{k}{for} \PYG{n}{idx}\PYG{p}{,} \PYG{n}{lbl} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{assignments}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{center} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{centroids}\PYG{p}{[}\PYG{n}{lbl}\PYG{p}{]}
            \PYG{n}{point} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{idx}\PYG{p}{]}
            \PYG{n}{total\PYGZus{}loss} \PYG{o}{+}\PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{(}\PYG{n}{point} \PYG{o}{\PYGZhy{}} \PYG{n}{center}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{loss} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{total\PYGZus{}loss}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{report}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Return a summary of clustering results.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{return} \PYG{p}{\PYGZob{}}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Method}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Static faiss.Kmeans}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Time (s)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{time\PYGZus{}taken}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Loss}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{loss}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Num Clusters}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{k}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cluster Sizes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{cid}\PYG{p}{:} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{idxs}\PYG{p}{)} \PYG{k}{for} \PYG{n}{cid}\PYG{p}{,} \PYG{n}{idxs} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cluster\PYGZus{}data\PYGZus{}indices}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{\sphinxstyleliteralintitle{\sphinxupquote{background.py}}}
\label{\detokenize{code:background-py}}

\section{\sphinxstyleliteralintitle{\sphinxupquote{logger.py}}}
\label{\detokenize{code:logger-py}}\sphinxSetupCaptionForVerbatim{logger.py}
\def\sphinxLiteralBlockLabel{\label{\detokenize{code:id3}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{import} \PYG{n+nn}{logging}

\PYG{k+kn}{from} \PYG{n+nn}{constants}\PYG{n+nn}{.}\PYG{n+nn}{filepath\PYGZus{}constants} \PYG{k+kn}{import} \PYG{n}{RESULTS\PYGZus{}DIR}

\PYG{k}{def} \PYG{n+nf}{setup\PYGZus{}logging}\PYG{p}{(}\PYG{n}{fileName} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{app.log}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} set up logging file, format and location, information level}

    \PYG{c+c1}{\PYGZsh{} logFormat = \PYGZdq{}\PYGZpc{}(asctime)s \PYGZhy{} \PYGZpc{}(levelname)s \PYGZhy{} \PYGZpc{}(message)s\PYGZdq{}}
    \PYG{n}{logFormat} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}(message)s}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{dateFormat} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZpc{}}\PYG{l+s+s2}{m/}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s2}{/}\PYG{l+s+s2}{\PYGZpc{}}\PYG{l+s+s2}{Y }\PYG{l+s+s2}{\PYGZpc{}}\PYG{l+s+s2}{H:}\PYG{l+s+s2}{\PYGZpc{}}\PYG{l+s+s2}{M:}\PYG{l+s+s2}{\PYGZpc{}}\PYG{l+s+s2}{S }\PYG{l+s+s2}{\PYGZpc{}}\PYG{l+s+s2}{p}\PYG{l+s+s2}{\PYGZdq{}}

    \PYG{c+c1}{\PYGZsh{} fileHandler}
    \PYG{n}{path} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{RESULTS\PYGZus{}DIR}\PYG{p}{,} \PYG{n}{fileName}\PYG{p}{)}
    \PYG{n}{file\PYGZus{}handler} \PYG{o}{=} \PYG{n}{logging}\PYG{o}{.}\PYG{n}{FileHandler}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

    \PYG{n}{logging}\PYG{o}{.}\PYG{n}{basicConfig}\PYG{p}{(}
        \PYG{n+nb}{format}\PYG{o}{=}\PYG{n}{logFormat}\PYG{p}{,} 
        \PYG{n}{datefmt}\PYG{o}{=}\PYG{n}{dateFormat}\PYG{p}{,}
        \PYG{n}{level}\PYG{o}{=}\PYG{n}{logging}\PYG{o}{.}\PYG{n}{DEBUG}\PYG{p}{,}
        \PYG{n}{handlers}\PYG{o}{=} \PYG{p}{[}
            \PYG{n}{file\PYGZus{}handler}\PYG{p}{,}
            \PYG{c+c1}{\PYGZsh{} stream\PYGZus{}handler}
        \PYG{p}{]}
    \PYG{p}{)}

    \PYG{n}{LOGGER} \PYG{o}{=} \PYG{n}{logging}\PYG{o}{.}\PYG{n}{getLogger}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{LOGGER}
\end{sphinxVerbatim}


\section{\sphinxstyleliteralintitle{\sphinxupquote{processer.py}}}
\label{\detokenize{code:processer-py}}\sphinxSetupCaptionForVerbatim{processer.py}
\def\sphinxLiteralBlockLabel{\label{\detokenize{code:id4}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{logging}
\PYG{k+kn}{from} \PYG{n+nn}{optimizer} \PYG{k+kn}{import} \PYG{n}{DynamicKmeansController}\PYG{p}{,} \PYG{n}{StaticKmeansController}
\PYG{k+kn}{from} \PYG{n+nn}{util} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{LOGGER} \PYG{o}{=} \PYG{n}{logging}\PYG{o}{.}\PYG{n}{getLogger}\PYG{p}{(}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} 2. 数据处理类}
\PYG{k}{class} \PYG{n+nc}{ComparisonProcessor}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    对比动态 vs 静态 聚类结果，存储以下信息：}
\PYG{l+s+sd}{      \PYGZhy{} center\PYGZus{}distance: 两组簇中心平均最近距离}
\PYG{l+s+sd}{      \PYGZhy{} dynamic\PYGZus{}loss, static\PYGZus{}loss}
\PYG{l+s+sd}{      \PYGZhy{} dynamic\PYGZus{}time, static\PYGZus{}time}
\PYG{l+s+sd}{      \PYGZhy{} dynamic\PYGZus{}history: loss \PYGZam{} time 历史}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{dynController}\PYG{p}{:}\PYG{n}{DynamicKmeansController}\PYG{p}{,} \PYG{n}{staController}\PYG{p}{:}\PYG{n}{StaticKmeansController}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dyn} \PYG{o}{=} \PYG{n}{ComparisonProcessor}\PYG{o}{.}\PYG{n}{summarize\PYGZus{}dynamic}\PYG{p}{(}\PYG{n}{dynController}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{sta} \PYG{o}{=} \PYG{n}{ComparisonProcessor}\PYG{o}{.}\PYG{n}{summarize\PYGZus{}static}\PYG{p}{(}\PYG{n}{staController}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{results} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}compute}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}compute\PYGZus{}center\PYGZus{}distance}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} 对于每个动态中心，找到距离最近的静态中心，计算平均距离}
        \PYG{n}{dyn\PYGZus{}c} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dyn}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{centroids}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
        \PYG{n}{sta\PYGZus{}c} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{sta}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{centroids}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
        \PYG{n}{dists} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n}{dyn\PYGZus{}c}\PYG{p}{:}
            \PYG{n}{diff} \PYG{o}{=} \PYG{n}{sta\PYGZus{}c} \PYG{o}{\PYGZhy{}} \PYG{n}{c}
            \PYG{n}{dist\PYGZus{}to\PYGZus{}sta} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{diff}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{n}{dists}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{dist\PYGZus{}to\PYGZus{}sta}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{return} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{dists}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}compute}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{results}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{center\PYGZus{}distance}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}compute\PYGZus{}center\PYGZus{}distance}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{results}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dynamic\PYGZus{}loss}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dyn}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loss}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{results}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{static\PYGZus{}loss}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{sta}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loss}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{results}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dynamic\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dyn}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{results}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{static\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{sta}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{results}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dynamic\PYGZus{}loss\PYGZus{}history}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dyn}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loss\PYGZus{}history}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{results}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dynamic\PYGZus{}time\PYGZus{}history}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dyn}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time\PYGZus{}history}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}


    \PYG{n+nd}{@staticmethod}
    \PYG{k}{def} \PYG{n+nf}{summarize\PYGZus{}dynamic}\PYG{p}{(}\PYG{n}{controller}\PYG{p}{:}\PYG{n}{DynamicKmeansController}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        输出动态聚类摘要信息}
\PYG{l+s+sd}{        Returns a dict with:}
\PYG{l+s+sd}{        \PYGZhy{} num\PYGZus{}clusters: 最终簇数}
\PYG{l+s+sd}{        \PYGZhy{} loss: 最终 loss}
\PYG{l+s+sd}{        \PYGZhy{} time: 累计运行时间}
\PYG{l+s+sd}{        \PYGZhy{} loss\PYGZus{}history: 每批 loss 的列表}
\PYG{l+s+sd}{        \PYGZhy{} time\PYGZus{}history: 每批累计时间的列表}
\PYG{l+s+sd}{        \PYGZhy{} centroids: 簇中心数组, shape=(k, D)}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n}{centroids} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{stack}\PYG{p}{(}\PYG{n}{controller}\PYG{o}{.}\PYG{n}{centroids}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k}{return} \PYG{p}{\PYGZob{}}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{method}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dynamic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{num\PYGZus{}clusters}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{centroids}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loss}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{controller}\PYG{o}{.}\PYG{n}{loss\PYGZus{}history}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{controller}\PYG{o}{.}\PYG{n}{time\PYGZus{}history}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loss\PYGZus{}history}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{controller}\PYG{o}{.}\PYG{n}{loss\PYGZus{}history}\PYG{p}{)}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time\PYGZus{}history}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{controller}\PYG{o}{.}\PYG{n}{time\PYGZus{}history}\PYG{p}{)}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{centroids}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{centroids}
        \PYG{p}{\PYGZcb{}}

    \PYG{n+nd}{@staticmethod}
    \PYG{k}{def} \PYG{n+nf}{summarize\PYGZus{}static}\PYG{p}{(}\PYG{n}{controller}\PYG{p}{:}\PYG{n}{StaticKmeansController}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        输出静态聚类摘要信息}
\PYG{l+s+sd}{        Returns a dict with:}
\PYG{l+s+sd}{        \PYGZhy{} num\PYGZus{}clusters: 簇数 k}
\PYG{l+s+sd}{        \PYGZhy{} loss: 最终 loss}
\PYG{l+s+sd}{        \PYGZhy{} time: 聚类耗时}
\PYG{l+s+sd}{        \PYGZhy{} centroids: 簇中心数组, shape=(k, D)}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{return} \PYG{p}{\PYGZob{}}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{method}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{static}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{num\PYGZus{}clusters}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{controller}\PYG{o}{.}\PYG{n}{k}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loss}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{controller}\PYG{o}{.}\PYG{n}{loss}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{controller}\PYG{o}{.}\PYG{n}{time\PYGZus{}taken}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{centroids}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{controller}\PYG{o}{.}\PYG{n}{centroids}
        \PYG{p}{\PYGZcb{}}



\end{sphinxVerbatim}


\section{\sphinxstyleliteralintitle{\sphinxupquote{plotter.py}}}
\label{\detokenize{code:plotter-py}}\sphinxSetupCaptionForVerbatim{plotter.py}
\def\sphinxLiteralBlockLabel{\label{\detokenize{code:id5}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{k+kn}{import} \PYG{n+nn}{logging}
\PYG{k+kn}{from} \PYG{n+nn}{processer} \PYG{k+kn}{import} \PYG{n}{ComparisonProcessor}
\PYG{k+kn}{from} \PYG{n+nn}{constants}\PYG{n+nn}{.}\PYG{n+nn}{filepath\PYGZus{}constants} \PYG{k+kn}{import} \PYG{n}{RESULTS\PYGZus{}DIR}

\PYG{n}{LOGGER} \PYG{o}{=} \PYG{n}{logging}\PYG{o}{.}\PYG{n}{getLogger}\PYG{p}{(}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{)}





\PYG{c+c1}{\PYGZsh{} 3. 画图类}
\PYG{k}{class} \PYG{n+nc}{ComparisonPlotter}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    接收 ComparisonProcessor, 绘制：}
\PYG{l+s+sd}{      \PYGZhy{} loss 对比 (bar)}
\PYG{l+s+sd}{      \PYGZhy{} time 对比 (bar)}
\PYG{l+s+sd}{      \PYGZhy{} 中心距离 (单个文本展示)}
\PYG{l+s+sd}{      \PYGZhy{} 动态聚类 loss \PYGZam{} time 历史曲线}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{comp}\PYG{p}{:} \PYG{n}{ComparisonProcessor}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{comp} \PYG{o}{=} \PYG{n}{comp}

    \PYG{k}{def} \PYG{n+nf}{plotAll}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{plot\PYGZus{}dynamic\PYGZus{}history}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{plot\PYGZus{}loss\PYGZus{}comparison}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{plot\PYGZus{}time\PYGZus{}comparison}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{plot\PYGZus{}loss\PYGZus{}comparison}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{labels} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dynamic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{static}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
        \PYG{n}{values} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{comp}\PYG{o}{.}\PYG{n}{results}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dynamic\PYGZus{}loss}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{comp}\PYG{o}{.}\PYG{n}{results}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{static\PYGZus{}loss}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{bar}\PYG{p}{(}\PYG{n}{labels}\PYG{p}{,} \PYG{n}{values}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Loss}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Dynamic vs Static Loss Comparison}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{plot\PYGZus{}time\PYGZus{}comparison}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{labels} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dynamic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{static}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
        \PYG{n}{values} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{comp}\PYG{o}{.}\PYG{n}{results}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dynamic\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{comp}\PYG{o}{.}\PYG{n}{results}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{static\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{bar}\PYG{p}{(}\PYG{n}{labels}\PYG{p}{,} \PYG{n}{values}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Time (s)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Dynamic vs Static Time Comparison}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{print\PYGZus{}center\PYGZus{}distance}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{dist} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{comp}\PYG{o}{.}\PYG{n}{results}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{center\PYGZus{}distance}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Average nearest\PYGZhy{}center distance between dynamic and static: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{dist}\PYG{l+s+si}{:}\PYG{l+s+s2}{.4f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{plot\PYGZus{}dynamic\PYGZus{}history}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Loss history}
        \PYG{n}{fig1} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{comp}\PYG{o}{.}\PYG{n}{results}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dynamic\PYGZus{}loss\PYGZus{}history}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Batch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Loss}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Dynamic Clustering Loss over Batches}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} Time history}
        \PYG{n}{fig2} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{comp}\PYG{o}{.}\PYG{n}{results}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dynamic\PYGZus{}time\PYGZus{}history}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Batch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cumulative Time (s)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Dynamic Clustering Time over Batches}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\section{\sphinxstyleliteralintitle{\sphinxupquote{util.py}}}
\label{\detokenize{code:util-py}}\sphinxSetupCaptionForVerbatim{util.py}
\def\sphinxLiteralBlockLabel{\label{\detokenize{code:id6}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}



\renewcommand{\indexname}{Index}
\printindex
\end{document}